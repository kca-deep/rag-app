# RAG 파이프라인 웹앱 구축 플랜 (완전개정판)

## 프로젝트 개요
망분리 환경에서 동작하는 엔터프라이즈급 RAG 파이프라인 웹 애플리케이션
- **UI 특성**: 1레벨 사이드바 + 모달 기반 상호작용
- **핵심 기능**: Collection별 문서 분리, API 키 관리, 실시간 모니터링
- **보안**: 역할 기반 접근 제어, 데이터 암호화, 감사 로깅

## 기술 스택

### Frontend
- **Next.js 15** + React 19 + TypeScript
- **Tailwind CSS v4** + shadcn/ui
- **상태 관리**: Zustand (전역) + TanStack Query (서버)
- **실시간**: Server-Sent Events

### Backend
- **FastAPI** + SQLAlchemy + Alembic
- **비동기 처리**: Celery + Redis
- **문서 처리**: Docling

### 데이터베이스
- **SQLite** (메타데이터, 트랜잭션)
- **Milvus** (벡터 저장)
- **Redis** (캐싱, 세션, 큐)

### 임베딩 & AI
- **OpenAI API** (text-embedding-3-small)
- **임베딩 캐싱** (성능 최적화)

## 아키텍처 설계

### 시스템 아키텍처
```
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│  Next.js    │───▶│   FastAPI    │───▶│   Milvus    │
│  Frontend   │    │   Backend    │    │   Vector    │
└─────────────┘    └──────────────┘    └─────────────┘
       │                   │                   │
       │            ┌──────┴──────┐           │
       │            │   SQLite    │           │
       │            │  Metadata   │           │
       │            └─────────────┘           │
       │                   │                   │
       └───────────────────┼───────────────────┘
                           │
                    ┌──────┴──────┐
                    │    Redis    │
                    │ Cache/Queue │
                    └─────────────┘
```

### 서비스 레이어 구조
```python
# Backend Service Architecture
┌─────────────────┐
│   API Layer     │  # FastAPI routes
├─────────────────┤
│  Service Layer  │  # Business logic
├─────────────────┤
│ Repository Layer│  # Data access
├─────────────────┤
│  Database Layer │  # SQLite + Milvus
└─────────────────┘
```

## 강화된 데이터베이스 설계

### SQLite 스키마 (트랜잭션 및 동기화 강화)

**핵심 테이블 구조:**
- **collections**: Collection 기본 정보, Milvus 연결 정보
- **documents**: 문서 메타데이터, 처리 상태, 동기화 상태
- **document_chunks**: 텍스트 청크, 임베딩 상태, Milvus ID 매핑
- **api_keys**: API 키 관리, 권한 제어, 사용량 제한
- **api_key_permissions**: Collection별 세부 권한 관리
- **api_usage_logs**: API 사용 내역, 성능 모니터링
- **sync_operations**: SQLite-Milvus 동기화 상태 추적
- **job_queue**: 비동기 작업 큐 관리
- **system_health**: 시스템 구성요소 건강성 체크
- **audit_logs**: 모든 데이터 변경 감사 로그

**RAG 최적화 테이블:**
- **query_cache**: 쿼리 결과 캐싱으로 성능 향상
- **search_feedback**: 검색 품질 개선을 위한 피드백 수집
- **conversation_context**: 대화 맥락 유지
- **chunk_analytics**: 청크별 접근 패턴 분석

**인덱스 전략:** 성능 최적화를 위한 복합 인덱스 구성
**트리거:** 자동 timestamp 갱신 및 데이터 일관성 유지

### Milvus Collection 전략 (RAG 최적화)

**동적 Collection 스키마 설계:**
- **필드 구성**: document_id, chunk_index, collection_id, embedding(1536차원), chunk_text, page_number, section_title
- **인덱스 전략**: 데이터 크기에 따른 적응형 인덱스 선택
  - 소규모(1만건 미만): IVF_FLAT (정확도 우선)
  - 중규모(10만건 미만): IVF_SQ8 (균형)
  - 대규모(10만건 이상): HNSW (속도 우선)

**성능 최적화 전략:**
- **임베딩 캐싱**: Redis를 통한 중복 임베딩 생성 방지
- **검색 결과 캐싱**: 자주 사용되는 쿼리 결과 캐싱
- **동적 필드**: 미래 확장성을 위한 동적 필드 지원

## 동기화 및 트랜잭션 관리

### 2단계 커밋 패턴
**트랜잭션 관리 전략:**
- **1단계 (Prepare)**: SQLite와 Milvus 모두에서 트랜잭션 준비 확인
- **2단계 (Commit)**: 모두 준비되면 동시 커밋, 실패 시 롤백
- **로그**: 모든 트랜잭션 성공/실패 상세 로깅

### 실패 복구 메커니즘
**자동 복구 전략:**
- **재시도**: 3회까지 자동 재시도 (지수 백오프)
- **알림**: 복구 불가능 시 관리자 알림
- **상태 추적**: sync_operations 테이블로 실시간 모니터링


## UI 구조 (모달 기반)

### v0.dev 스타일 UI 개발 가이드

**핵심 원칙:**
- **컴포넌트 중심 사고**: 모든 UI 요소를 재사용 가능한 컴포넌트로 설계
- **섹션 기반 레이아웃**: 페이지를 논리적 섹션으로 분할하여 구성
- **일관된 spacing**: 4, 6, 8, 12, 16px 기준으로 일관된 간격 적용
- **컴포지션 패턴**: 작은 컴포넌트들을 조합하여 복잡한 UI 구성
- **props 기반 변형**: variant, size, state props를 활용한 컴포넌트 다변화

**UI 패턴:**
- **카드 기반 레이아웃**: 정보 그룹화를 위한 Card 컴포넌트 활용
- **그리드 시스템**: CSS Grid와 Flexbox를 활용한 반응형 레이아웃
- **계층적 네비게이션**: Breadcrumb과 계층적 메뉴 구조
- **즉시 피드백**: 모든 인터랙션에 대한 즉각적인 시각적 피드백
- **상태 중심 UI**: loading, error, empty, success 상태별 UI 분기

**컴포넌트 구성 전략:**
- **Compound Component**: 관련된 UI 요소들을 논리적으로 그룹화
- **Render Props**: 유연한 컴포넌트 커스터마이징
- **Forward Ref**: 외부에서 DOM 접근이 필요한 컴포넌트
- **As Prop**: 다형성을 지원하는 컴포넌트 설계

### 1. 대시보드 (/)
- **실시간 통계 카드**: Collections, 문서, API 키, 금일 요청
- **시스템 상태**: Milvus, Redis, 동기화 상태
- **빠른 액션**: Collection 생성, 문서 업로드, API 키 발급

### 2. Collection 관리 (/collections)
- **Collection 테이블**: 이름, 문서수, 상태, 최종 업데이트
- **필터 & 검색**: 상태별, 이름별 필터링
- **Collection 상세 모달**:
  - 기본 정보 수정
  - 문서 목록 (페이지네이션)
  - Milvus 통계
  - 동기화 상태

### 3. 문서 관리 (/documents)
- **다중 필터**: Collection, 상태, 날짜 범위
- **배치 작업**: 다중 선택, 일괄 삭제/재처리
- **문서 상세 모달**:
  - 메타데이터 정보
  - 처리 로그 (타임라인)
  - 청크 목록 (가상 스크롤)
  - 동기화 상태

### 4. 검색 (/search)
- **고급 검색 옵션**: 유사도 임계값, 결과 수, Collection 선택
- **검색 결과**: Collection별 그룹화, 하이라이팅
- **검색 히스토리**: 최근 검색어, 저장된 검색

### 5. API 키 관리 (/api-keys)
- **API 키 테이블**: 이름, 상태, 권한, 사용량, 만료일
- **사용량 차트**: 시간별, 일별, Collection별 사용 패턴
- **API 키 상세 모달**:
  - 권한 관리 (Collection별)
  - 실시간 사용량 통계
  - 사용 히스토리 (페이지네이션)
  - IP 제한 설정

## 배포 및 운영

### 개발 환경 설정
**필수 구성 요소:**
- Node.js (Frontend)
- Python 3.8+ (Backend)
- Redis (캐싱 및 큐)
- Milvus (벡터 데이터베이스)
- SQLite (메타데이터)

**환경 변수 설정:**
- OPENAI_API_KEY: OpenAI API 키
- DATABASE_URL: SQLite 데이터베이스 경로
- REDIS_URL: Redis 연결 정보
- MILVUS_HOST/PORT: Milvus 연결 정보


## 핵심 워크플로우

### 1. 지능형 문서 처리 워크플로우
```
사용자 업로드 → 파일 타입 감지 → 구조 분석 (섹션/표/목록) →
적응형 청킹 → 청크 품질 검증 → 임베딩 생성 (캐시 확인) →
메타데이터 강화 → Milvus 저장 → 인덱스 최적화 →
동기화 확인 → 실시간 UI 업데이트
```

### 2. AI 챗봇 RAG 검색 워크플로우
```
쿼리 수신 → API 키 검증 → 쿼리 해시 생성 → 캐시 확인 →
임베딩 생성 (캐시 활용) → 하이브리드 검색 (벡터+키워드) →
결과 재순위화 → 컨텍스트 확장 → 권한 필터링 →
결과 하이라이팅 → 사용량 로깅 → 캐시 저장 → 응답
```

### 3. 실시간 상태 업데이트
```
백엔드 이벤트 발생 → Server-Sent Events →
프론트엔드 수신 → Query Cache 무효화 →
UI 자동 업데이트 → 사용자 알림
```

### 4. 검색 품질 최적화 워크플로우
```
사용자 피드백 수집 → 검색 패턴 분석 → 청크 인기도 추적 →
검색 알고리즘 조정 → A/B 테스트 → 성능 메트릭 수집 →
자동 최적화 적용 → 품질 모니터링
```

## 최종 정리

이 플랜은 **AI 챗봇을 위한 엔터프라이즈급 RAG 파이프라인** 구축을 위한 완전한 가이드입니다.

### 핵심 특징
✅ **AI 챗봇 최적화**: 하이브리드 검색, 컨텍스트 확장, 배치 처리
✅ **엔터프라이즈 보안**: API 키 관리, 권한 제어, 감사 로깅
✅ **고성능**: 캐싱 전략, 인덱스 최적화, 비동기 처리
✅ **확장성**: Collection별 분리, 동적 인덱싱, 모듈화 설계
✅ **모니터링**: 실시간 상태 추적, 성능 메트릭, 자동 알림

### 구현 우선순위
1. **1단계**: 기본 RAG 파이프라인 구축
2. **2단계**: AI 챗봇 전용 API 구현
3. **3단계**: 성능 최적화 및 캐싱
4. **4단계**: 고급 기능 (하이브리드 검색, 피드백)

이제 완벽한 AI 챗봇 RAG 시스템 구축이 가능합니다! 🚀